#!/usr/bin/env python

__version__ = "2.0-beta3"

__doc__ = """OneTime: an open source encryption program that uses one-time pads.

(Run 'onetime --help' for usage information.)

The usual public-key encryption programs, such as GnuPG, are probably
secure for everyday purposes, but their implementations are too
complex for all but the most knowledgeable programmers to vet, and
in some cases there may be vulnerable steps in the supply chain
between GnuPG's authors and the end user.  When bootstrapping trust,
it helps to start with something you can trust by inspection.

Hence this script, OneTime, a simple encryption program that works
with one-time pads.  If you don't know what one-time pads are, this
program may not be right for you.  If you do know what they are and
how to use them, this program can make using them more convenient.

OneTime takes care of some of the pad-management bureacracy for you.
It avoids re-using pad data -- except when decrypting the same
encrypted message twice, of course -- by maintaining records of pad
usage in ~/.onetime/pad-records.  (The pads themselves are not stored
there, just records about pad usage.)  

Recommended practice: if you are Alice communicating with Bob, then
keep two different pads, 'alice_to_bob.pad' and 'bob_to_alice.pad', as
opposed to sharing the same pad for both directions of communication.
With two separate pads, even if you each send a message simultaneously
to the other with no advance planning, you still won't accidentally
use any of the same pad data twice, assuming you let OneTime do its
bookkeeping naturally.

See http://en.wikipedia.org/wiki/One-time_pad for more information
about one-time pads in general.

OneTime is written by Karl Fogel and distributed under an MIT-style
open source license; run 'onetime --license' or see the LICENSE file
in the full distribution for complete licensing information.
OneTime's home page is http://www.red-bean.com/onetime/.
"""

import os
import sys
import stat
import getopt
import bz2
import base64
import hashlib
import re
import xml
import xml.dom
import xml.dom.minidom


# Set up booleans that older Pythons didn't have, if necessary.
try:
  True
except:
  True = 1
  False = 0

# The current format level.
#
# Some background is needed to understand what this means:
#
# The first releases of OneTime (the 1.x series) did not include any
# indication of the format, in the plaintext headers of the output.
# This was deliberate: after all, if there *were* a format change in
# the future, a "Format:" header could be added, and its presence
# would indicate that the output was clearly from a later version than
# the 1.x series.
#
# Well, that has now happened -- but instead of specifying an exact
# format version in the plaintext header, we just specify that the
# format is "internal", and in the code we call this a "format level"
# instead of a "format version".  We distinguish between this new
# "internal" level and the old level (now retroactively labeled
# "original"), for the purpose of supporting OneTime 1.x and earlier,
# but beyond that the plaintext headers do not say anything further
# about the format.
#
# There are a couple of reasons to do it this way.  One, so we get
# away from the idea that the version of OneTime is relevant, since
# that what really matters is just the format -- which can and often
# will remain unchanged, or at least backward-compatible, from version
# to version of OneTime.  Two, starting from OneTime 2.0, all detailed
# format version information is embedded in "inner headers" in the
# ciphertext (see the Pad class for details), not in the plaintext
# headers.  This avoids leaking information about the earliest
# possible date on which the message could have been encrypted,
# because the encrypted message will reveal nothing more than that the
# tool used to encrypt must have been OneTime 2.0 or higher.
#
# Therefore, instead of using numbers for the format level, we use one
# of two words: "internal" or "original".
#
# Note that the "original" format had a (rather embarrassing) bug
# whereby plaintext was encrypted and then then compressed, instead of
# the other way around.  This is fixed in all the "internal" level
# formats, and of course any further format details are now embedded
# in the cipthertext, in the manner described in the Pad class.
Format_Level = "internal"

class Pad:
  """An encoder/decoder associated with a specific pad at a specific offset.
Feed bytes through convert() to XOR them against the pad.

A Pad is used for a single encryption or decryption session; it should
not be used for subsequent sessions -- instead, a new Pad object
should be generated (it might refer to the same underlying pad file,
but it still needs to be a new object due to certain initializations).
  """

  # Length of the front stretch of pad used for the ID, which is a
  # SHA1 of these bytes, which are then never used for encryption.
  # (And why 32, given that a SHA1 hash only holds 20 bytes anyway?
  # No reason, except the usual religious bias toward powers of 2.)
  id_source_length = 32

  def __init__(self, pad_path):
    """Initialize a new pad, using padfile PAD_PATH.  The pad cannot be
  used for encoding or decoding until set_offset() is called."""
    self.pad_path = pad_path
    self.padfile = open(self.pad_path, "rb")
    self.pad_size = os.stat(self.pad_path)[stat.ST_SIZE]
    self._offset = None  # where to start using pad bytes (must initialize)
    self._length = 0  # number of pad bytes used this time
    self._id = None
    self._original_format_level_id = None
    self._default_fuzz_source_length = 2   # See _make_fuzz_length_from_pad()
    self._default_fuzz_source_modulo = 512 # and see _make_inner_header().

    # Most of what a pad does is the same for encoding and decoding --
    # after all, the conversion step is XOR, which is symmetrical.
    #
    # However, before conversion can happen, the pad needs to know
    # whether to write or read the inner header flag bytes -- so for
    # that it needs to know whether it's encoding or decoding.  When
    # that step is done, the appropriate variable below is set;
    # exactly one of them *must* be set before any conversion happens.
    self._encoding = False
    self._decoding = False
    # False until conversion starts, True thereafter.
    self._begun = False
    
  class PadUninitialized(Exception):
    """Exception raised if Pad hasn't been initialized yet."""
    pass

  class OverPrepared(Exception):
    """Exception raised if a Pad is initialized or prepared twice."""
    pass

  class PadShort(Exception):
    """Exception raised if Pad doesn't have enough data for this encryption."""
    pass

  class FormatLevel(Exception):
    """Exception raised if an unknown format level is specified."""
    pass

  class InnerFormat(Exception):
    """Exception raised if something is wrong with the inner format."""
    pass

  def prepare_for_encoding(self):
    """Mark this Pad as encoding.  This or prepare_for_decoding() must
    be called exactly once, before any conversion happens."""
    if self._encoding:
      raise Pad.OverPrepared("already prepared for encoding")
    if self._decoding:
      raise Pad.OverPrepared("cannot prepare for both encoding and decoding")
    self._encoding = True

  def prepare_for_decoding(self):
    """Mark this Pad as decoding.  This or prepare_for_encoding() must
    be called exactly once, before any conversion happens."""
    if self._decoding:
      raise Pad.OverPrepared("already prepared for decoding")
    if self._encoding:
      raise Pad.OverPrepared("cannot prepare for both decoding and encoding")
    self._decoding = True

  def set_offset(self, offset):
    """Set this pad's encoding/decoding offset to OFFSET."""
    if offset >= self.pad_size:
      raise Pad.PadShort("offset exceeds pad size, need more pad")
    self._offset = offset
    self.padfile.seek(self._offset)

  def convert(self, string, format_level="internal"):
    """If STRING is not empty or None, return it as XORed against the pad;
else return the empty string.  Note STRING may be empty on intermediate
calls simply because a compressor has not yet had enough incoming data to
work with, not necessarily because input is ended yet.

If FORMAT_LEVEL is "original", then don't perform the random
distance skip (the "fuzz") that is part of the encryption process for
internal format levels."""
    result = ''
    if self._offset is None:
      raise Pad.PadUninitialized("pad not yet initialized (no offset)")
    if format_level == "internal":
      if self._encoding and self._decoding:
        raise Pad.OverPrepared(
          "pad cannot encode and decode simultaneously")
      elif not self._encoding and not self._decoding:
        raise Pad.PadUninitialized(
          "pad not yet prepared for either encoding or decoding")
      elif not self._begun:
        if self._encoding:
          inner_header_data = self._make_inner_header()
          result += inner_header_data
          self._length += len(inner_header_data)
        else: # self._decoding is set
          string = self._handle_inner_header(string)

    string_len = len(string)
    pad_str = self.padfile.read(string_len)
    if len(pad_str) < string_len:
      raise Pad.PadShort("not enough pad data available to finish encryption")
    for i in range(string_len):
      result += chr(ord(string[i]) ^ ord(pad_str[i]))
    self._length += string_len
    self._begun = True
    return result


  def _get_id(self):
    """Get the ID for this pad."""
    saved_posn = self.padfile.tell()
    self.padfile.seek(0)
    sha1 = hashlib.sha1()
    string = self.padfile.read(Pad.id_source_length)
    sha1.update(string)
    self.padfile.seek(saved_posn)
    return sha1.hexdigest()

  def _get_original_format_level_id(self):
    """Get the OneTime \"original\" format level ID for this pad.
    In that format level, Pad IDs were based on the first 1024
    (octet) bytes of the pad.  This was needlessly spendy, or rather,
    it would have been needlessly spendy if OneTime 1.x had been
    paranoid enough to not use any of those bytes for encryption.
    Version 2.0 fixed this, reducing the number of bytes used on ID but
    also making they are not used for encryption."""
    saved_posn = self.padfile.tell()
    self.padfile.seek(0)
    sha1 = hashlib.sha1()
    string = self.padfile.read(1024)
    sha1.update(string)
    self.padfile.seek(saved_posn)
    return sha1.hexdigest()

  def id(self, format_level="internal"):
    """Return the pad's ID.
    If FORMAT_LEVEL is specified, return ID according to that format level."""
    if format_level == "internal":
      if self._id is None:
        self._id = self._get_id()
      return self._id
    elif format_level == "original":
      if self._original_format_level_id is None:
        self._original_format_level_id = self._get_original_format_level_id()
      return self._original_format_level_id
    else:
      raise Pad.FormatLevel("unknown format \"%s\" for ID" % format_level)

  def path(self):
    """Return the pad's path."""
    return self.pad_path

  def offset(self):
    """Return offset from which encoding/decoding starts."""
    return self._offset

  def length(self):
    """Return the number of pad bytes used so far."""
    return self._length

  def _make_fuzz_length_from_pad(self, num_bytes, modulo):
    """Return a fuzz skip len based on the next NUM_BYTES bytes % MODULO,
    advancing the pad accordingly."""
    # What's going on here?  What is "fuzz"?
    #
    # "Fuzz" is a distance we skip forward in the pad before
    # starting to use pad data for encryption or decryption; the
    # exact distance can only be known by those who know the pad.
    #
    # The distance skipped may be determined in two ways:
    #
    #   1) Read some bytes from the current location in the pad, use
    #      those bytes to calculate (in some deterministic way) the
    #      fuzz distance to skip.
    #
    #   2) Read a sender-specified distance that is encrypted in the
    #      pad right here ("here" being right after the inner header
    #      bytes), and then skip that distance.
    #
    # Right now we only use method (1), but support for method (2) is
    # built into the internal format.
    #
    # Here's how method (1) works:
    #
    # First we read NUM_BYTES bytes from the pad.  This is before any
    # of the pad has been used for encoding or decoding.
    #
    # We then portably convert that sequence of bytes to a number
    # modulo MODULO.  The result is the number of bytes forward to
    # skip in the pad before starting to consume pad data for use in
    # actual conversion, that is, in encoding or decoding.
    #
    # Two possible improvements would be: skip by bits instead of
    # bytes, so we get 8 times the variability for the amount of pad
    # used up, or just go all the way and use some constant number of
    # pad bytes as the key in a standard (e.g., block cipher) symmetric
    # encryption algorithm run on the data before it is pad-encrypted.
    # 
    # Skipping by bits would complicate the code, however, since all
    # the seeking and I/O is natively aligned on 8-bit boundaries.  As
    # for doing full symmetric encryption "underneath" the pad, that's
    # not a bad idea, but there isn't any library for that in the core
    # Python distribution, and sticking to stuff available in standard
    # Python is a design goal, to make distribution easier.
    fuzz_length_source = self.padfile.read(num_bytes)
    self._length += num_bytes
    if len(fuzz_length_source) < num_bytes:
      raise Pad.PadShort("not enough pad available to supply fuzz source")
    fuzz_skip_len = 1
    for x in fuzz_length_source:
      # We don't use int.from_bytes(), as it's only available in
      # Python >= 3.2.  Instead, we just multiply the bytes together
      # (as eight-bit values) and take the modulo of that.  It would
      # be more space-efficient to convert multiple bytes together as
      # a word-sized number of some kind, but that's harder to do
      # portably, and this has to work everywhere consistently.
      #
      # Since the current modulo is 512 and the default fuzz source
      # length is 2, we could have just done
      #
      #   sum([ord(x) for x in fuzz_length_source]) % 512
      #
      # But we may want to increase modulo and/or default fuzz source
      # length later; multiplying all the bytes together is as
      # efficient as we can be while maintaining portability.
      fuzz_skip_len *= ord(x)
    return fuzz_skip_len % modulo

  def _skip_bytes(self, num_bytes):
    """Skip NUM_BYTES bytes forward in this pad."""
    try:
      self.padfile.seek(self.padfile.tell() + num_bytes)
      self._length += num_bytes
    except EOFError:
      raise Pad.PadShort("not enough pad available to supply fuzz")

  def _make_inner_header(self):
    """Return inner header data to be encoded in the output.
    This must happen before any conversion of plaintext to ciphertext
    is done, so it must be called after the Pad has been initialized
    but before self.convert() has consumed any pad for actual conversion."""
    inner_header = ''
    if self._offset is None:
      raise Pad.PadUninitialized("pad not yet initialized (no offset)")
    # We first jump to the offset specified by the plaintext headers.
    # Then we'll read a set series of (pad-encrypted) bytes, some of
    # which may specify that further bytes should be read.  The bits
    # will give flags for various options.  Here is the list of the
    # byte(s) and flag bits:
    # 
    #   First byte is internal format version -- think of it as the
    #   "x" in "internal.x", where "internal" comes from the plaintext
    #   "Format:" header.  Values 0-127 are interpreted as numbers;
    #   values > 128 mean combine this byte with the next byte
    #   (recursively, big endian).
    # 
    #   In internal format 0, the next byte after the internal format
    #   version holds flag bits:
    # 
    #     0b_______*: 0 means use the default fuzz length
    #                 1 means look at next byte for fuzz length
    #     0b______*_: reserved; must be 0 in internal format 0
    #     0b_____*__: reserved; must be 0 in internal format 0
    #     0b____*___: reserved; must be 0 in internal format 0
    #     0b___*____: reserved; must be 0 in internal format 0
    #     0b__*_____: reserved; must be 0 in internal format 0
    #     0b_*______: reserved; must be 0 in internal format 0
    #     0b*_______: reserved; must be 0 in internal format 0
    # 
    #   If the first bit were set, then the next byte would indicate
    #   something about the fuzz length.  That might either be a
    #   sender-chosen definite length (still masked by the pad of
    #   course), or a length partly determined by the pad (as per the
    #   current code below) but with a sender-chosen minimum.  That's
    #   all TBD: we don't support internal format 1 yet, only 0, and
    #   in 0 the skip-distance comes entirely from pad data.
    # 
    #   The meanings of the rest of the flag bits are not yet
    #   determined, and their values must be zero in format 2.0.
    #
    # First byte is inner format version (currently 0), next byte
    # indicates how to determine fuzz_source length.  Of course, both
    # bytes need to be encoded by the pad.
    next_pad_byte = ord(self.padfile.read(1))
    self._length += 1
    inner_header_format_version = 0 ^ next_pad_byte
    next_pad_byte = ord(self.padfile.read(1))
    self._length += 1
    fuzz_source_length_indicator = 0 ^ next_pad_byte
    # Now that we've taken care of the start of the header, we can
    # figure out how far to skip in the pad, and then do the skip.
    #
    # self._default_fuzz_source_modulo is 512.  Why 512?
    #
    # Even in a known-plaintext case, an attacker does not know the
    # pad, so skipping a random distance based on pad data ensures the
    # attacker can't reliably substitute some other plaintext for the
    # original: they'd have only a 1-in-512 chance of guessing the
    # right distance to skip.
    #
    # We don't want to skip too far forward -- that would be wasteful
    # of pad, and pad might be expensive.  So we'll skip forward
    # 0 <= N <= 511 bytes, N having been determined by the small bit
    # of pad data we just read.  It's tempting to set a higher modulus
    # and make it a 1-in-1024 chance or something, but given the rate
    # at which I at least can generate new pad data, that feels too
    # costly.  512 feels like the right point in the tradeoff slider
    # -- but if anyone has data to support a different number, please
    # speak up.
    #
    # Of course, two bytes means we could go all the way up to 65535,
    # so most of this code can stay the same if we later decide to
    # expand the range.  (There's no particular reason the modulus has
    # to be a power of two, either.)
    #
    # These precautions greatly reduce the effectiveness of the
    # known-plaintext message authentication attack.  Still, even now
    # if you were to send the same message to, say, 512 people who are
    # all using the same pad, and that exact plaintext were known to
    # the attacker, and the attacker were to have active intercept
    # capability with the recipients, then for some small number of
    # those recipients, the attacker could substitute some other
    # forged message in place of your original plaintext.  But the
    # attacker wouldn't know which subsitutions were successful, and
    # the rest of the recipients would receive an obviously garbage
    # message.  Given the number of prerequisites there, and the
    # unavoidable & easily detectable failure mode for the attacker,
    # this does not seem like a serious weakness to me, but comments
    # always welcome of course.
    #
    # Remember that the 512 should not be thought of as a key length.
    # The number of possibilities here is 1-in-512, not 1-in-(2^512).
    fuzz_skip_len = self._make_fuzz_length_from_pad(
      self._default_fuzz_source_length, self._default_fuzz_source_modulo)
    self._skip_bytes(fuzz_skip_len)
    return chr(inner_header_format_version) + chr(fuzz_source_length_indicator)

  def _handle_inner_header(self, string):
    """Handle inner header data at front of STRING, return remainder of STRING.
    This must happen before any conversion of ciphertext to plaintext
    is done, so it must be called after the Pad has been initialized
    but before self.convert() has consumed any pad for actual conversion."""
    # See self._make_inner_header() for inner header documentation.
    inner_format_version = None
    if self._offset is None:
      raise Pad.PadUninitialized("pad not yet initialized (no offset)")
    next_pad_byte = ord(self.padfile.read(1))
    self._length += 1
    pad_encoded_byte = ord(string[0])
    inner_format_version = pad_encoded_byte ^ next_pad_byte
    if inner_format_version == 0:
      first_flag_byte = ord(string[1]) ^ ord(self.padfile.read(1))
      self._length += 1
      if first_flag_byte & 1 == 0:
        fuzz_skip_len = self._make_fuzz_length_from_pad(
          self._default_fuzz_source_length, self._default_fuzz_source_modulo)
        self._skip_bytes(fuzz_skip_len)
      else:
        raise Pad.InnerFormat("cannot yet handle custom fuzz_source length")
      # Enforce the fact that we don't use any of the other flag bits yet.
      if (   first_flag_byte &   2 != 0
          or first_flag_byte &   4 != 0
          or first_flag_byte &   8 != 0
          or first_flag_byte &  16 != 0
          or first_flag_byte &  32 != 0
          or first_flag_byte &  64 != 0
          or first_flag_byte & 128 != 0):
        raise Pad.InnerFormat("first flag byte has unknown flags set (%s)"
                              % bin(first_flag_byte))
    else:
      raise Pad.InnerFormat("unknown inner format version \"%d\""
                            % inner_format_version)
    return string[2:]

  def __str__(self):
    """Return a string representation of this pad."""
    return "Pad '%s' (%s):\n   Offset: %d\n   Length: %d\n" \
           % (self.path(), self.id(), self.offset(), self.length())

class PadEncoder:
  """Class for encoding raw data to OneTime output."""

  class UnknownCompressionException(Exception):
    """Exception raised when an unknown compression method is requested."""
    pass

  def __init__(self, pad, config):
    """Initialize an encoder for PAD with Configuration CONFIG."""
    self.pad = pad
    self.config = config
    # We use bz2 compression unconditionally.  If we offered a choice,
    # we'd have to name that choice somewhere for use in decryption.
    # But if we were to list the choice in the open headers, then we
    # would reveal something about the plaintext.  On the other hand,
    # if we were to name it in "inner headers" that are also masked by
    # the pad, that would complexify the code a great deal (we know
    # because we tried -- see the 2.x branch history) and that would
    # defeat part of the point of this program: to be so simple as to
    # be trivially auditable.  So just use bz2.  The worst case is ok.
    self.compressor = bz2.BZ2Compressor()
    self.pad.prepare_for_encoding()

  def encode(self, string):
    """Return onetime-encoded data for STRING, or the empty string if none.
    Consume pad as needed."""
    out = ''
    compressed_plaintext = self.compressor.compress(string)
    if len(compressed_plaintext) > 0:
      out = base64.encodestring(self.pad.convert(compressed_plaintext))
    return out

  def finish(self):
    "Return last remaining bits of crypttext, or None if none left."
    remainder = self.pad.convert(self.compressor.flush())
    if remainder:
      remainder = base64.encodestring(remainder)
    self.config.record_consumed(self.pad, False)
    return remainder


class PadDecoder:
  """Class for decoding OneTime output back to plaintext."""

  class DecodingError(Exception):
    """Exception raised when something goes wrong decoding."""
    pass

  def __init__(self, pad, config, format_level):
    """Initialize a decoder for PAD with Configuration CONFIG.
    FORMAT_LEVEL indicates the OneTime format level of the incoming
    data, i.e., the value given in the output's "Format:" header."""
    self.pad = pad
    self.config = config
    self.unused_data = ""
    self.format_level = format_level
    self.decompressor = bz2.BZ2Decompressor()

    if self.format_level != "original" and self.format_level != "internal":
      raise Pad.FormatLevel(
        "impossible format level: \"%s\"" % self.format_level)
    self.pad.prepare_for_decoding()

  def decode(self, string):
    """Return all available onetime-decoded data so far, including for STRING,
    or return None if no decoded data is ready yet.  Throw IOError if
    data is not decodable.  Throw EOFError exception if called past
    the end of decodable data.  Store any unused data in self.unused_data."""
    ret = ""
    if self.format_level == "original":
      # Format level "original" got the compression/encryption order
      # wrong.  Look, this is embarrassing.  I'm only telling you
      # about it because we still need to support that mis-ordering
      # for compatibility.
      ret = self.pad.convert((self.decompressor.decompress(
      base64.b64decode(string))), format_level="original")
    else: # must be format level "internal"
      ret = self.decompressor.decompress(self.pad.convert(
        base64.b64decode(string)))
    self.unused_data += self.decompressor.unused_data
    return ret

  def finalize(self):
    """Finalize pad usage with the configuration."""
    self.config.record_consumed(self.pad, True)


class Configuration:
  """A parsed representation of one user's ~/.onetime/ configuration area.
  A .onetime/ directory contains just a 'pad-records' file right now.

  Even in cases where we're operating without touching permanent
  storage, a Configuration instance is still created and updated
  internally.  This is partly because the Configuration does some
  consistency checks on incoming/outgoing data, and partly because it
  would be useful if we're ever providing an API.
  """

  class ConfigurationError(Exception):
    """Exception raised if we encounter an impossible state in a
    Configuration."""
    pass

  def __init__(self, path=None):
    """Initialize a new configuration.

    If PATH is None, try to find or create the config area in the
    standard location in the user's home directory; otherwise, find or
    create it at PATH.

    If PATH is \"-\", instantiate a Configuration object but do not
    connect it to any activity on disk; it will neither read from nor
    write to permanent storage."""

    self.config_area = path
    if self.config_area is None:
      self.config_area = os.path.join(os.path.expanduser("~"), ".onetime")
    self.pad_records_file = os.path.join(self.config_area, "pad-records")
    # Create the configuration area if necessary.
    if self.config_area != '-' and not os.path.isdir(self.config_area):
      # Legacy data check: if they have a ~/.otp dir, that's probably
      # from a previous incarnation of this program, when it was named
      # "otp".  If so, just rename the old config area.
      old_config_area = os.path.join(os.path.expanduser("~"), ".otp")
      old_pad_records_file = os.path.join(old_config_area, "pad-records")
      if os.path.isfile(old_pad_records_file):
        os.rename(old_config_area, self.config_area)
      else:
        os.mkdir(self.config_area)

    # Create the pad-records file if necessary.
    if self.config_area != '-' and not os.path.isfile(self.pad_records_file):
      open(self.pad_records_file, "w").close()
    # Parse the pad-records file (if any) in the configuration area.
    self.pad_records = self._parse_pad_records_file()
    
  def _consolidate_used_ranges(self, used, allow_reconsumption=False):
    """Return a consolidated version of USED.  USED is a list of
    tuples, indicating offsets and lengths:

       [ (OFFSET1, LENGTH1), (OFFSET2, LENGTH2), ... ]

    Consolidation means returning a list of equal or shorter length,
    that marks exactly the same ranges as used, but expressed in the
    most compact way possible.  For example:

       [ (0, 10), (10, 20), (20, 25) ]

    would become

       [ (0, 25) ]

    If ALLOW_RECONSUMPTION is False, raise a ConfigurationError
    exception if the input is incoherent, such as a range beginning
    inside another range.  But if ALLOW_RECONSUMPTION is True, allow
    ranges to overlap.  Typically, it will be False when encoding and
    True when decoding, because it's legitimate to decode a message
    multiple times, as long as no one re-uses that range for encoding."""
    new_used = [ ]
    last_offset = None
    last_length = None

    for tup in used:
      (this_offset, this_length) = tup
      if last_offset is not None:
        if last_offset + last_length >= this_offset:
          # It's only reconsumption if the end of the previous range
          # extends past the next offset.  So we error on that if
          # we're not allowing reconsumption...
          if (last_offset + last_length > this_offset
              and not allow_reconsumption):
            raise self.ConfigurationError(
              "pad's used ranges are incoherent:\n   %s" % str(used))
          # ...but otherwise we just extend the range from the
          # original offset, whether it was a true overlap or a
          # snuggle-right-up-against kind of thing:
          else:
            # All the possible cases are:
            #
            #   1) first tuple entirely precedes second
            #   2) second tuple begins inside first but ends after it
            #   3) second tuple begins and ends inside first
            #   4) second tuple begins *before* first and ends in it
            #   5) second tuple begins and ends before first
            #
            # However, due to the conditional above, we must be in (2)
            # or (3), and we only need to adjust last_length if (2).
            if (this_offset + this_length) > (last_offset + last_length):
              last_length = (this_offset - last_offset) + this_length
        else:
          new_used.append((last_offset, last_length))
          last_offset = this_offset
          last_length = this_length
      else:
        last_offset = this_offset
        last_length = this_length
    if last_offset is not None:
      new_used.append((last_offset, last_length))
    return new_used

  def _get_next_offset(self, used):
    """Return the next free offset from USED, which assumed to be in
    consolidated form.  The minimum returned is Pad.id_source_length;
    that way the Pad ID stretch is always accounted for, even if USED
    was initialized from an old original-format pad record."""
    cur_offset = None
    # We don't do anything fancy, just get the earliest available
    # offset past the last used tuple.  This means that any ranges in
    # between tuples are wasted.  See comment in main() about
    # discontinuous ranges for why this is okay.
    for tup in used:
      (this_offset, this_length) = tup
      cur_offset = this_offset + this_length
    if cur_offset is None or cur_offset < Pad.id_source_length:
      return Pad.id_source_length
    else:
      return cur_offset
    
  def _parse_pad_records_file(self):
    """Return a dictionary representing this configuration's 'pad-records'
    file (e.g., ~/.onetime/pad-records).  If the file is empty, just
    return an empty dictionary.

    The returned dictionary is keyed on pad IDs, with sub-dictionaries
    as values.  Each sub-dictionary's keys are the remaining element
    names inside a pad element, and the value of the 'used' element is
    a list of tuples, each tuple of the form (OFFSET, LENGTH).  So:

       returned_dict[SHA1_SUM] ==> subdict
       subdict['used'] ==> [(OFFSET1, LENGTH1), (OFFSET2, LENGTH2), ...]
       subdict['some_elt_name'] ==> SOME_ELT_VALUE       <!-- if any -->
       subdict['another_elt_name'] ==> ANOTHER_ELT_VALUE <!-- if any -->

    A 'pad-records' file is an XML document like this:

      <?xml version="1.0" encode="UTF-8"?>
      <!DOCTYPE TYPE_OF_DOC SYSTEM/PUBLIC "dtd-name">
      <onetime-pad-records>
         <pad-record>
           <id>SHA1_HASH_OF_FIRST_KILOBYTE_OF_PAD</id>
           <used><offset>OFFSET_A</offset>
                 <length>LENGTH_A</length></used>
           <used><offset>OFFSET_B</offset>
                 <length>LENGTH_B</length></used>
           ...
         </pad-record>
         <pad-record>
           <id>SHA1_HASH_OF_FIRST_KILOBYTE_OF_PAD</id>
           <used><offset>OFFSET_C</offset>
                 <length>LENGTH_C</length></used>
           ...
         </pad-record>
         ...
      </onetime-pad-records>
      """
    dict = { }

    if self.config_area == '-':
      return dict

    try:
      dom = xml.dom.minidom.parse(self.pad_records_file)

      for pad in dom.firstChild.childNodes:
        id = None
        path = None
        used = [ ]
        if pad.nodeType == xml.dom.Node.ELEMENT_NODE:
          subdict = { }
          for pad_part in pad.childNodes:
            if pad_part.nodeType == xml.dom.Node.ELEMENT_NODE:
              if pad_part.nodeName == "id":
                id = pad_part.childNodes[0].nodeValue
              elif pad_part.nodeName == "used":
                offset = None
                length = None
                for used_part in pad_part.childNodes:
                  if used_part.nodeName == "offset":
                    offset = int(used_part.childNodes[0].nodeValue)
                  if used_part.nodeName == "length":
                    length = int(used_part.childNodes[0].nodeValue)
                used.append((offset, length))
                subdict["used"] = self._consolidate_used_ranges(used)
              else:
                # Parse unknown elements transparently.
                subdict[pad_part.nodeName] = pad_part.childNodes[0].nodeValue
          if not subdict.has_key("used"):
            # We don't require the "used" element to be present; if it's
            # absent, it just means none of this pad has been used yet.
            subdict["used"] = [ (0, 0) ]
          dict[id] = subdict
    except xml.parsers.expat.ExpatError:
      pass
    return dict
    
  def save(self):
    """Save the pad-records file, and maybe commit it."""
    if self.config_area == '-':
      return
    tempfile = self.pad_records_file + ".tmp"
    # Deliberately not setting binary mode here; this is a text file.
    fp = open(tempfile, 'w')
    fp.write("<onetime-pad-records>\n")
    for pad_id in self.pad_records.keys():
      fp.write("  <pad-record>\n")
      fp.write("    <id>%s</id>\n" % pad_id)
      for tuple in self._consolidate_used_ranges(
          self.pad_records[pad_id]["used"]):
        fp.write("    <used><offset>%d</offset>\n" % tuple[0])
        fp.write("          <length>%d</length></used>\n" % tuple[1])
      for key in self.pad_records[pad_id].keys():
        if key != "used":
          fp.write("    <%s>%s</%s>\n" % \
                   (key, self.pad_records[pad_id][key], key))
      fp.write("  </pad-record>\n")
    fp.write("</onetime-pad-records>\n")
    fp.close()
    os.rename(tempfile, self.pad_records_file)

  def register(self, pad):
    """Register PAD if it is not already registered, and set its
    offset based on previously used regions for that pad, if any."""
    next_offset = None
    # This is a little complicated only because we need; to look for
    # old original-style pad IDs and upgrade them if present.
    if not self.pad_records.has_key(pad.id()):
      if self.pad_records.has_key(pad.id(format_level="original")):
        # Upgrade original-style record to internal style.
        self.pad_records[pad.id()] = self.pad_records[pad.id(format_level="original")]
        del self.pad_records[pad.id(format_level="original")]
      else:
        # Initialize a new internal-style record.
        self.pad_records[pad.id()] = { "used" : [ ] }
    else:
      if self.pad_records.has_key(pad.id(format_level="original")):
        raise Configuration.ConfigurationError(
          "Pad has both v2 and v1 IDs present in pad-records file:\n" \
          "  v2: %s\n"                                                \
          "  v1: %s\n"                                                \
          "This is supposed to be impossible.  Please resolve."       \
          % (pad.id(), pad.id(format_level="original")))
    # One way or another, we now have an up-to-date v2 pad record.
    # Set the next offset accordingly.
    next_offset = self._get_next_offset(self.pad_records[pad.id()]["used"])
    pad.set_offset(next_offset)

  def record_consumed(self, pad, allow_reconsumption):
    """Record that PAD has used PAD.length() bytes starting at PAD.offset().

    If ALLOW_RECONSUMPTION is False, raise a ConfigurationError
    if reconsuming any part of a range that has been consumed previously.
    But if ALLOW_RECONSUMPTION is True, allow ranges to overlap.
    Typically, it is False when encoding and True when decoding,
    because it's okay to decode a message multiple times, but not to
    re-use a range for encoding."""
    used = self.pad_records[pad.id()]["used"]
    used.append((pad.offset(), pad.length()))
    self.pad_records[pad.id()]["used"] = self._consolidate_used_ranges(
      used, allow_reconsumption)
    pass

  def show_pad_records(self):
    """Print pad records, presumably for debugging."""
    for pad_id in self.pad_records.keys():
      print "Pad %s:" % pad_id
      print "  used:", self.pad_records[pad_id]["used"]


def license(outfile=sys.stdout):
  """Print open source license information to OUTFILE."""
  # Looks like we're maintaining this in parallel with the LICENSE
  # file.  I'd like to avoid that, but I don't see how.  The MIT
  # license text itself won't change, but the copyright years will
  # from time to time, and the copyright holder could as well.
  license_str = """\
OneTime version %s.

Copyright (c)  2004-2013  Karl Fogel

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
""" % __version__
  outfile.write(license_str)


def pad_generation_help(outfile=sys.stdout):
  """Print information on how to generate a pad."""
  help_str = """\
How to Generate a One-Time Pad
==============================

These commands will create a pad on computers that have a local source
of random bytes at /dev/random and the ability to copy those bytes
with the `dd` command.  Most GNU/Linux computers can do this.

  $ mkdir -p ~/.onetime
  $ dd if=/dev/random of=~/.onetime/to_foo.pad bs=1000 count=10000

That command will place a 10 megabyte pad in ~/.onetime/to_foo.pad
(1000000 bytes is one megabyte).  That pad will be good for encrypting
10 megabytes of data before it should be retired.  If you anticipate
sending more than 10 megabytes of data with the same pad, you will
want to replace 10 with a higher count.  On some computers, large pads
may take a long time (even days) to generate.  Just let dd work while
you do other things.

To encrypt a file named WALLET.DAT with that pad:

  $ onetime -e -p ~/.onetime/to_foo.pad WALLET.DAT

(produces WALLET.DAT.onetime).
"""
  outfile.write(help_str)
  

def usage(outfile=sys.stdout):
  """Print usage information to OUTFILE."""
  usage_str = """\
OneTime version %s, an open source encryption program that uses one-time pads.

Typical usage:

  onetime -e -p PAD MSG           (encrypt; write output to 'MSG.onetime')
  onetime -d -p PAD MSG.onetime   (decrypt; output loses '.onetime' suffix)

Other usage modes:

  onetime [-e|-d] -p PAD -o OUTPUT INPUT  (both INPUT and OUTPUT are files)
  onetime [-e|-d] -p PAD -o - INPUT       (output goes to stdout)
  onetime [-e|-d] -p PAD                  (input from stdin, output to stdout)
  onetime [-e|-d] -p PAD -o OUTPUT        (input from stdin, output to OUTPUT)

OneTime remembers what ranges of what pad files have been used, and avoids
re-using those ranges when encrypting, by keeping records in ~/.onetime/.

All options:

   -e                      Encrypt
   -d                      Decrypt
   -p PAD | --pad=PAD      Use PAD for pad data.
   -o OUT | --output=OUT   Output to file OUT ("-" for stdout)
   --offset=N              Control the pad data start offset
   -n | --no-trace         Leave no record of pad usage in your config
   -C DIR | --config=DIR   Specify DIR (instead of ~/.onetime) as config area;
                           '-' for DIR means use no config area (implies -n)
   --show-id               Show a pad's ID; used with -p only
   --intro                 Show an introduction to OneTime and one-time pads
   -v | -V | --version     Show version information
   --license               Show full open source license information
   --pad-help              Show help on how to generate one-time pads
   -? | -h | --help        Show usage
""" % __version__
  outfile.write(usage_str)


def main():
  encrypting  = False
  decrypting  = False
  pad_file    = None
  incoming    = None
  output      = None
  output_name = None
  offset      = None
  config_area = None
  debug       = False
  error_exit  = False
  show_pad_id = False
  no_trace    = False

  try:
    opts, args = getopt.getopt(sys.argv[1:],
                               'edp:o:h?vVnC:',
                               [ "encrypt", "decrypt",
                                 "pad=",
                                 "output=",
                                 "offset=",
                                 "config=",
                                 "show-id",
                                 "no-trace",
                                 "debug",
                                 "intro", "help", "pad-help",
                                 "version", "license"])
  except getopt.GetoptError:
    sys.stderr.write("Error: problem processing options\n")
    usage(sys.stderr)
    sys.exit(1)

  for opt, value in opts:
    if opt == '--help' or opt == '-h' or opt == '-?':
      usage()
      sys.exit(0)
    if opt == '--pad-help':
      pad_generation_help()
      sys.exit(0)
    if opt == '--intro':
      print __doc__,
      sys.exit(0)
    elif opt == '--version' or opt == '-v' or opt == '-V':
      print "OneTime version %s" % __version__
      sys.exit(0)
    elif opt == '--license':
      license()
      sys.exit(0)
    elif opt == '--encrypt' or opt == '-e':
      encrypting = True
    elif opt == '--decrypt' or opt == '-d':
      decrypting = True
    elif opt == '--pad' or opt == '-p':
      pad_file = value
    elif opt == '--output' or opt == '-o':
      if value == "-":
        output = sys.stdout
      else:
        output_name = value
        output = open(output_name, "wb")
    elif opt == '--offset':
      offset = int(value)
    elif opt == '--config' or opt == '-C':
      config_area = value
    elif opt == '--show-id':
      show_pad_id = True
    elif opt == '--no-trace' or opt == '-n':
      no_trace = True
    elif opt == '--debug':
      debug = 1
    else:
      sys.stderr.write("Error: unrecognized option: '%s'\n" % opt)
      error_exit = True

  if show_pad_id:
    if encrypting or decrypting:
      sys.stderr.write("Error: cannot use --show-id with -e or -d.\n")
      error_exit = True
  elif not encrypting and not decrypting:
    sys.stderr.write("Error: must pass either '-e' or '-d'.\n")
    error_exit = True

  if encrypting and decrypting:
    sys.stderr.write("Error: cannot pass both '-e' and '-d'.\n")
    error_exit = True

  if not pad_file:
    sys.stderr.write("Error: must specify pad file with -p.\n")
    error_exit = True

  if len(args) == 0 or args[0] == "-":
    incoming = sys.stdin
    if output is None:
      # If incoming is stdin, output defaults to stdout.
      output = sys.stdout
  elif len(args) == 1:
    incoming = open(args[0], "rb")
    if output is None:
      if encrypting:
        # If plaintext input is 'FILENAME', output defaults to
        # 'FILENAME.onetime'.
        output_name = args[0] + ".onetime"
      else:
        # If crypttext input is 'FILENAME.onetime', output defaults to
        # 'FILENAME'.  But we also look for ".otp", for compatibility
        # with older versions of this program.
        if args[0].endswith(".onetime"):
          output_name = args[0][:-8]
        elif args[0].endswith(".otp"):
          output_name = args[0][:-4]
        else:
          sys.stderr.write(
            "Error: input filename does not end with '.onetime' or '.otp'.\n")
          error_exit = True
      output = open(output_name, "wb")

  elif len(args) > 1:
    sys.stderr.write("Error: unexpected arguments: %s\n" % args[1:])
    error_exit = True

  if offset is not None and offset < Pad.id_source_length:
      sys.stderr.write("Error: argument to --offset must be >= %d\n"
                       % Pad.id_source_length)
      error_exit = True

  if error_exit:
    usage(sys.stderr)
    sys.exit(1)

  pad = Pad(pad_file)

  config = Configuration(config_area)
  config.register(pad)

  if show_pad_id:
    print pad.id()
    print "  Note that older versions of OneTime (v1 and before) " \
      + "would have reported"
    print "  %s.  This v1 ID output may go away" \
      % pad.id(format_level="original")
    print "  in a future release, so please do not depend on its presence."
    sys.exit(0)

  if offset is not None:
    pad.set_offset(offset)
    offset = None  # junk this; we'll rely on pad for offset from now on

  # The first line of OneTime format level "internal" is the begin line.
  # Then comes the header: a group of lines followed by a blank line.
  # Then comes the encoded body.
  # The last line indicates the end, and is distinguishable from
  #   encoded content by inspection 
  onetime_begin = "-----BEGIN OneTime MESSAGE-----\n"
  old_onetime_begin = "-----BEGIN OTP MESSAGE-----\n"   # compat
  onetime_header = "%s" % onetime_begin                        \
               + "Format: %s" % Format_Level                   \
               + "  << NOTE: OneTime 1.x and older "           \
               +              "cannot read this format. >>\n"  \
               + "Pad ID: %s\n" % pad.id()                     \
               + "Offset: %s\n" % pad.offset()                 \
               + "\n"
  onetime_end = "-----END OneTime MESSAGE-----\n"
  old_onetime_end = "-----END OTP MESSAGE-----\n"       # compat

  # We could use pads more efficiently, by encrypting with multiple
  # discontinuous ranges to avoid the "sparse wasted space" problem.
  # However, the common case is that someone uses the same pad
  # successively with one interlocutor, and in that case there would
  # be no benefit to seeking out small unused ranges and consuming
  # them -- we'd pay a price in code complexity but the extra code
  # would in practice rarely or never be exercised.  Random numbers
  # aren't so expensive that they're worth that extra complexity.
  # However, we could add it in a future format rev if it ever looks
  # like a good idea.  Note that the discontinuous encrypted sections
  # would need to be embedded opaquely in the encoded output; it would
  # not be acceptable for there to be multiple plaintext "Offset:"
  # headers (or whatever) visible, as that would reveal something
  # about pad usage patterns and thus about past communications.

  if encrypting:
    output.write(onetime_header)
    encoder = PadEncoder(pad, config)
    while 1:
      string = incoming.read(8192)
      if len(string) > 0:
        result = encoder.encode(string)
        if result:
          output.write(result)
      else:
        result = encoder.finish()
        if result:
          output.write(result)
        break
    output.write("\n")
    output.write(onetime_end)

  elif decrypting:
    decoder = None # Will set to a decoder when know incoming format level.
    saw_end = None
    maybe_header_line = incoming.readline()
    if (maybe_header_line != onetime_begin
        and maybe_header_line != old_onetime_begin):
      sys.stderr.write("Error: malformed OneTime format: no begin line.\n")
      sys.exit(1)
    while maybe_header_line != "\n":
      maybe_header_line = incoming.readline()
      m = re.match("Offset: ([0-9]+)", maybe_header_line)
      if m:
        # Note we don't have to adjust the received offset here to
        # compensate for the 32-byte Pad ID stretch, because the
        # recorded offset in *both* "original" and "internal" format
        # ciphertexts is an absolute offset from the true edge of the
        # Pad.  The "internal" format Pad ID stretch is already
        # reflected in the offset for modern files, and if an incoming
        # ciphertext is in original format, then naturally we just use
        # whatever offset it requests.
        #
        # (When the pad record is written back out, the 32 bytes for
        # the ID will be recorded as consumed no matter what, because
        # config.register() takes care of that.  But in practice, most
        # plaintexts will have already used more than that anyway, so
        # that safeguard is probably redundant here.)
        pad.set_offset(int(m.group(1)))
        continue
      m = re.match("Format: ([a-zA-Z0-9-]+) ", maybe_header_line)
      if m:
        format_level = m.group(1)
        decoder = PadDecoder(pad, config, format_level)
        continue

    if decoder is None:
      # If we saw no format header, it must be the old, original format.
      decoder = PadDecoder(pad, config, "original")

    while 1:
      string = incoming.readline()
      if (string == onetime_end or string == old_onetime_end):
        saw_end = 1
        break
      if len(string) > 0:
        try:
          result = decoder.decode(string)
        except (IOError, Pad.InnerFormat, PadDecoder.DecodingError) as e:
          output.close()
          if output_name is not None:
            os.remove(output_name)
          raise e
        except EOFError:
          if string == "\n":
            # It's just the blank line between the end of the base64
            # data and the onetime_end marker.  Continue, because the
            # next thing we read should be the onetime_end marker.
            continue
          else:
            output.close()
            if output_name is not None:
              os.remove(output_name)
            raise PadDecoder.DecodingError(
              "unexpected input: '%s'" % string)
        if result:
          output.write(result)
      else:
        break
    decoder.finalize()
    if not saw_end:
      sys.stderr.write("Error: malformed OneTime format: no end line.\n")
      sys.exit(1)

  if (encrypting or decrypting) and not no_trace:
    config.save()

  if debug:
    config.show_pad_records()

if __name__ == '__main__':
  main()
